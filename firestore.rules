rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // =============== FONCTIONS UTILITAIRES ===============
    
    function isAuthenticated() {
      return request.auth != null;
    }

    // âš¡ VÃ©rifier l'accÃ¨s utilisateur via la collection userAccess (sÃ©curitÃ© maximale)
    function hasRestaurantAccess(restaurantId) {
      return isAuthenticated() && 
             // VÃ©rification directe dans la collection userAccess
             exists(/databases/$(database)/documents/restaurants/$(restaurantId)/userAccess/$(request.auth.uid));
    }
    
    // ğŸ¯ VÃ©rifier le rÃ´le via la collection userAccess
    function hasRole(restaurantId, role) {
      return isAuthenticated() && 
             // Lecture du document userAccess pour obtenir le rÃ´le
             get(/databases/$(database)/documents/restaurants/$(restaurantId)/userAccess/$(request.auth.uid)).data.role == role;
    }
    
    // ğŸ‘‘ VÃ©rifier si l'utilisateur est manager via userAccess
    function isManager(restaurantId) {
      return hasRole(restaurantId, 'manager');
    }
    
    // ğŸ”§ VÃ©rifier si l'utilisateur est super-admin (Custom Claims conservÃ©s pour cette fonction globale)
    function isSuperAdmin() {
      return isAuthenticated() && 
             request.auth.token.superAdmin == true;
    }
    
    
    // =============== COLLECTIONS PRINCIPALES ===============
    
    // ğŸª RESTAURANTS : DonnÃ©es des restaurants
    // âš ï¸ SÃ‰CURITÃ‰ MAXIMALE : Aucune modification directe autorisÃ©e
    match /restaurants/{restaurantId} {
      allow read: if isAuthenticated() && hasRestaurantAccess(restaurantId);
      allow write: if false;
      allow create: if isAuthenticated;
      allow update: if false;
      allow delete: if false;
      
      // =============== SOUS-COLLECTIONS ===============
      
      // âŒ USER ACCESS : Gestion des accÃ¨s utilisateurs
      // âš ï¸ SÃ‰CURITÃ‰ CRITIQUE : Aucune modification directe autorisÃ©e
      match /userAccess/{userId} {
        allow read: if isAuthenticated() && 
                       (request.auth.uid == userId || 
                        isManager(restaurantId) || 
                        isSuperAdmin());
        allow write: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
      }
      
      // ğŸ“‹ MENUS : Utilisateurs avec accÃ¨s au restaurant
      match /menus/{menuId} {
        allow read: if hasRestaurantAccess(restaurantId);
        allow write: if hasRestaurantAccess(restaurantId);

      }
      
      // ğŸ« TICKETS : Gestion des tickets avec conditions sur le statut
      match /tickets/{ticketId} {
        allow read: if hasRestaurantAccess(restaurantId);
        
        // CrÃ©ation : Utilisateurs autorisÃ©s
        allow create: if hasRestaurantAccess(restaurantId);
        
        // Modification : INTERDITE si le ticket est inactif (active: false)
        allow update: if hasRestaurantAccess(restaurantId) && resource.data.active == true;
                                
        // Suppression : INTERDITE
        allow delete: if false
      }
      
      // ğŸ“Š STOCK : Utilisateurs avec accÃ¨s au restaurant
      match /stock/{itemId} {
        allow read: if hasRestaurantAccess(restaurantId);
        allow write: if hasRestaurantAccess(restaurantId);
      }
      
      // ğŸ§¹ MISSIONS : Utilisateurs avec accÃ¨s au restaurant
      match /missions/{missionId} {
        allow read: if hasRestaurantAccess(restaurantId);
        allow create: if hasRestaurantAccess(restaurantId) && isManager(restaurantId);
        allow update: if hasRestaurantAccess(restaurantId);
        allow delete: if hasRestaurantAccess(restaurantId);
      }
      
      // ğŸ’° COMPTABILITÃ‰ : Managers uniquement
      match /accounting/{docId} {
        allow read, write: if hasRestaurantAccess(restaurantId) && isManager(restaurantId);
      }
      
      // ğŸ”§ CONFIGURATION : Managers uniquement
      match /settings/{settingId} {
        allow read: if hasRestaurantAccess(restaurantId);
        allow write: if hasRestaurantAccess(restaurantId) && isManager(restaurantId);
      }
      
      // âŒ PROTECTION GLOBALE : Toute autre sous-collection
      match /{path=**} {
        allow read, write: if hasRestaurantAccess(restaurantId);                       
      }
    }
    
    // =============== COLLECTIONS UTILISATEURS ===============
    
    // ğŸ‘¤ USERS : DonnÃ©es personnelles des utilisateurs
    match /users/{userId} {
      // Lecture : PropriÃ©taire ou super-admin
      allow write, read, update: if isAuthenticated() && (request.auth.uid == userId || isSuperAdmin());
    }
    
    // =============== COLLECTIONS DE LOGS ET AUDIT ===============
    
    // ğŸ“‹ AUDIT LOGS : Logs d'audit (lecture seule pour utilisateurs)
    match /audit-logs/{logId} {
      allow read: if isSuperAdmin();
      allow write: if false; // Ã‰criture uniquement via Functions
    }
    
    // ğŸš¨ SECURITY EVENTS : Ã‰vÃ©nements de sÃ©curitÃ©
    match /security-events/{eventId} {
      allow read: if isSuperAdmin();
      allow write: if false; // Ã‰criture uniquement via Functions
    }

  
    }
    
    // =============== COLLECTIONS PUBLIQUES ===============
    
    // ğŸª RESTAURANT DIRECTORY : RÃ©pertoire public des restaurants
    match /restaurant_directory/{restaurantId} {
      // Lecture publique pour dÃ©couverte
      allow read: if true;
      allow write: if isAuthenticated() && isManager(restaurantId);
    }
    
    // =============== RÃˆGLES PAR DÃ‰FAUT ===============
    
    // âŒ REFUS PAR DÃ‰FAUT : Toute autre collection est interdite
    match /{document=**} {
      allow read, write: if false;
    }
  }


// =============== COMMENTAIRES DE SÃ‰CURITÃ‰ ===============

/*
ğŸ” SÃ‰CURITÃ‰ ULTRA-RENFORCÃ‰E AVEC USERACCESS :

1. âœ… AUTHENTIFICATION REQUISE
   - Toutes les opÃ©rations nÃ©cessitent une authentification Firebase

2. ğŸ¯ AUTORISATION VIA USERACCÃˆS (NOUVEAU)
   - VÃ©rification directe dans restaurants/{id}/userAccess/{uid}
   - Plus de dÃ©pendance aux Custom Claims pour l'accÃ¨s
   - ContrÃ´le par rÃ´le via userAccess.role
   - VÃ©rification de l'expiration via userAccess.expiresAt

3. âœ… SÃ‰PARATION DES DONNÃ‰ES
   - Isolation parfaite par restaurant
   - AccÃ¨s utilisateur UNIQUEMENT via documents userAccess

4. ğŸš« PROTECTION TRIPLE COUCHE
   - Collection 'restaurants' : AUCUNE modification directe
   - Collection 'userAccess' : AUCUNE modification directe
   - Sous-collections : AccÃ¨s uniquement si userAccess existe

5. âœ… CONTRÃ”LE DES FONCTIONS CRITIQUES
   - UserAccess gÃ©rÃ© uniquement via Functions
   - Audit logs protÃ©gÃ©s en Ã©criture
   - Logique mÃ©tier centralisÃ©e cÃ´tÃ© serveur

6. âœ… SESSIONS ET LOGS
   - Sessions isolÃ©es par utilisateur
   - Logs d'audit pour traÃ§abilitÃ©

ğŸš¨ POINTS CRITIQUES ULTRA-SÃ‰CURISÃ‰S :

- âŒ IMPOSSIBLE de modifier restaurants/{id} directement
- âŒ IMPOSSIBLE de modifier restaurants/{id}/userAccess/{uid} directement
- âœ… SEULE la prÃ©sence dans userAccess autorise l'accÃ¨s au restaurant
- âœ… Chaque opÃ©ration vÃ©rifie l'existence du document userAccess
- âœ… Protection absolue : mÃªme sans Custom Claims, userAccess fait autoritÃ©

ğŸ“Š NOUVELLE ARCHITECTURE DE SÃ‰CURITÃ‰ :

Client App (React Native/Web)
    â†“ (Lecture conditionnelle)
Firestore Rules (VÃ©rification userAccess)
    â†“ (Lecture de restaurants/{id}/userAccess/{uid})
Document UserAccess (Source de vÃ©ritÃ©)
    â†“ (Si existe â†’ accÃ¨s autorisÃ©)
Collections Restaurant + Sous-collections

ğŸ›¡ï¸ AVANTAGES DE CETTE ARCHITECTURE :

1. SÃ©curitÃ© au niveau de la base de donnÃ©es (pas de JWT)
2. ContrÃ´le granulaire par restaurant
3. RÃ©vocation instantanÃ©e (suppression userAccess)
4. Audit complet via collections Firestore
5. ImpossibilitÃ© de falsifier les permissions

âš¡ CONSIDÃ‰RATIONS PERFORMANCE :

- Chaque opÃ©ration lit le document userAccess
- Utilisation recommandÃ©e du cache Firestore
- Index requis sur les collections userAccess
- Optimisation via rÃ¨gles exists() vs get()

ğŸ¯ STRUCTURE USERACCÃˆS REQUISE :

restaurants/{restaurantId}/userAccess/{userId} {
  role: 'manager' | 'waiter' | 'chef' | 'cleaner',
  expiresAt: timestamp | null,
  grantedAt: timestamp,
  grantedBy: string
}

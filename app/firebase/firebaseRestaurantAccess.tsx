import { httpsCallable, getFunctions, connectFunctionsEmulator, Functions } from 'firebase/functions';
import { 
  collection, 
  getDocs, 
  query, 
  where, 
  collectionGroup
} from 'firebase/firestore';
import { auth, db } from './firebaseConfig';

// =============== CONFIGURATION ===============

// Initialiser Firebase Functions
const functions: Functions = getFunctions();

// Pour le d√©veloppement local (√©mulateur)
if (__DEV__) {
  // Connexion √† l'√©mulateur Functions pour √©viter les erreurs CORS
  connectFunctionsEmulator(functions, 'localhost', 5001);
  console.log('ÔøΩÔøΩ Mode d√©veloppement : Fonctions connect√©es √† l\'√©mulateur local (localhost:5001)');
}

// =============== INTERFACES V2 (ARCHITECTURE SANS DUPLICATION) ===============

interface RestaurantUserAccessV2 {
  role: 'manager' | 'waiter' | 'chef' | 'cleaner';
  grantedAt: number;
  grantedBy: string;
  expiresAt: number;
  isActive: boolean;
  permissions: string[];
  lastActivity: number;
  loginCount: number;
  metadata?: {
    ip?: string;
    userAgent?: string;
    geoLocation?: string;
  };
}

interface RestaurantAccessDataV2 {
  restaurantId: string;
  role: 'manager' | 'waiter' | 'chef' | 'cleaner';
  expiresAt?: number;
  targetUserId?: string; // UID Firebase
  targetUserEmail?: string; // Email utilisateur (sera r√©solu en UID c√¥t√© serveur)
}

interface RestaurantAccessResult {
  success: boolean;
  message: string;
  expiresAt?: number;
  restaurantAccess?: { [key: string]: any };
  totalRestaurants?: number;
  details?: any;
  architecture?: string; // Indique la version utilis√©e (v2-robust)
}

// =============== FONCTIONS PRINCIPALES V2 (FIRESTORE DIRECT) ===============

/**
 * üéØ V2 : Accorder l'acc√®s restaurant √† un utilisateur (sous-collection directe)
 */
export const grantRestaurantAccessV2 = async (
  restaurantId: string, 
  role: 'manager' | 'waiter' | 'chef' | 'cleaner',
  expiresAt?: number,
  targetUserId?: string
): Promise<RestaurantAccessResult> => {
  try {
    console.log(`üéØ V2: Attribution acc√®s ${role} pour restaurant ${restaurantId}`);
    
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    const currentTime = Date.now();
    const expirationTime = expiresAt || (currentTime + (7 * 24 * 60 * 60 * 1000));

    // ‚úÖ UNIQUEMENT la Firebase Function V2 qui g√®re tout (Firestore + Custom Claims)
    const setRestaurantAccessV2Func = httpsCallable<RestaurantAccessDataV2, RestaurantAccessResult>(
      functions, 
      'setRestaurantAccessV2'
    );
    
    // ‚ö†Ô∏è IMPORTANT: Utiliser l'UID Firebase Auth pour les custom claims, pas l'email converti
    const firebaseUid = targetUserId || auth.currentUser.uid;
    
    const result = await setRestaurantAccessV2Func({
      restaurantId,
      role,
      expiresAt: expirationTime,
      targetUserId: firebaseUid  // Passer l'UID Firebase, pas l'email converti
    });

    console.log('‚úÖ V2: Acc√®s accord√© et Custom Claims mis √† jour via Functions');
    return {
      success: true,
      message: 'Acc√®s accord√© avec succ√®s',
      expiresAt: expirationTime,
      architecture: 'v2-functions-only',
      details: result.data
    };
    
  } catch (error: any) {
    console.error('‚ùå V2: Erreur attribution acc√®s:', error);
    throw new Error(`Erreur attribution acc√®s V2: ${error.message}`);
  }
};

/**
 * üö´ V2 : Supprimer l'acc√®s restaurant (sous-collection directe)
 */
export const revokeRestaurantAccessV2 = async (
  restaurantId: string,
  targetUserId?: string
): Promise<RestaurantAccessResult> => {
  try {
    console.log(`üö´ V2: Suppression acc√®s restaurant ${restaurantId}`);
    
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    // ‚úÖ UNIQUEMENT la Firebase Function V2 qui g√®re tout (Firestore + Custom Claims)
    const removeRestaurantAccessV2Func = httpsCallable<{ restaurantId: string; targetUserId?: string }, RestaurantAccessResult>(
      functions, 
      'removeRestaurantAccessV2'
    );
    
    const result = await removeRestaurantAccessV2Func({ 
      restaurantId, 
      targetUserId 
    });

    console.log('‚úÖ V2: Acc√®s supprim√© et Custom Claims mis √† jour via Functions');
    return {
      success: true,
      message: 'Acc√®s supprim√© avec succ√®s',
      architecture: 'v2-functions-only',
      details: result.data
    };
    
  } catch (error: any) {
    console.error('‚ùå V2: Erreur suppression acc√®s:', error);
    throw new Error(`Erreur suppression acc√®s V2: ${error.message}`);
  }
};

/**
 * üìã V2 : Obtenir tous les restaurants de l'utilisateur (Collection Group Query)
 */
export const getMyRestaurantAccessV2 = async (targetUserId?: string): Promise<RestaurantAccessResult> => {
  try {
    console.log('üìã V2: R√©cup√©ration des restaurants via Collection Group');
    
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    const userId = targetUserId || auth.currentUser.uid;
    const currentTime = Date.now();

    // Collection Group Query : chercher dans toutes les sous-collections userAccess
    const userAccessQuery = query(collectionGroup(db, 'userAccess'),where('__name__', '==', userId));

    const querySnapshot = await getDocs(userAccessQuery);
    const restaurantAccess: { [key: string]: any } = {};

    querySnapshot.forEach((doc) => {
      const data = doc.data();
      // Extraire l'ID du restaurant du chemin du document
      const restaurantId = doc.ref.parent.parent?.id;
      
      if (restaurantId && data.isActive && (!data.expiresAt || data.expiresAt > currentTime)) {
        restaurantAccess[restaurantId] = data;
      }
    });

    console.log('‚úÖ V2: Restaurants r√©cup√©r√©s via Collection Group');
    return {
      success: true,
      message: 'Restaurants r√©cup√©r√©s avec succ√®s',
      restaurantAccess,
      totalRestaurants: Object.keys(restaurantAccess).length,
      architecture: 'v2-collectiongroup'
    };
    
  } catch (error: any) {
    console.error('‚ùå V2: Erreur r√©cup√©ration restaurants:', error);
    throw new Error(`Erreur r√©cup√©ration restaurants V2: ${error.message}`);
  }
};

/**
 * üë• V2 : Obtenir tous les utilisateurs d'un restaurant (sous-collection directe)
 */
export const getRestaurantUsersV2 = async (
  restaurantId: string,
  includeInactive = false
): Promise<RestaurantAccessResult> => {
  try {
    console.log(`üë• V2: R√©cup√©ration utilisateurs restaurant ${restaurantId}`);
    
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    // R√©cup√©rer tous les documents de la sous-collection userAccess
    const userAccessRef = collection(db, 'restaurants', restaurantId, 'userAccess');
    const querySnapshot = await getDocs(userAccessRef);
    
    const users: { [key: string]: any } = {};
    const currentTime = Date.now();

    querySnapshot.forEach((doc) => {
      const data = doc.data();
      const userId = doc.id;
      
      // Filtrer selon les crit√®res
      const isExpired = data.expiresAt && data.expiresAt < currentTime;
      const shouldInclude = includeInactive || (data.isActive && !isExpired);
      
      if (shouldInclude) {
        users[userId] = {
          ...data,
          userId
        };
      }
    });

    console.log('‚úÖ V2: Utilisateurs r√©cup√©r√©s de la sous-collection');
    return {
      success: true,
      message: 'Utilisateurs r√©cup√©r√©s avec succ√®s',
      details: users,
      totalRestaurants: Object.keys(users).length,
      architecture: 'v2-subcollection'
    };
    
  } catch (error: any) {
    console.error('‚ùå V2: Erreur r√©cup√©ration utilisateurs:', error);
    throw new Error(`Erreur r√©cup√©ration utilisateurs V2: ${error.message}`);
  }
};

/**
 * üéØ V2 : Cr√©er le premier manager d'un restaurant (bootstrap)
 */
export const bootstrapRestaurantManagerV2 = async (restaurantId: string, ownerEmail?: string
): Promise<RestaurantAccessResult> => {
  try {
    console.log(`üéØ V2: Cr√©ation premier manager pour restaurant ${restaurantId}`);
    
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    // ‚úÖ Appeler la Firebase Function V2 pour cr√©er le premier manager
    const bootstrapFunc = httpsCallable<{ restaurantId: string; ownerEmail?: string }, RestaurantAccessResult>(
      functions, 
      'bootstrapRestaurantManagerV2'
    );
    
    const result = await bootstrapFunc({
      restaurantId, 
      ownerEmail
    });

    console.log('‚úÖ V2: Premier manager cr√©√© via Functions');
    return {
      success: true,
      message: 'Premier manager cr√©√© avec succ√®s',
      architecture: 'v2-bootstrap',
      details: result.data
    };
    
  } catch (error: any) {
    console.error('‚ùå V2: Erreur cr√©ation premier manager:', error);
    throw new Error(`Erreur cr√©ation premier manager V2: ${error.message}`);
  }
};

/**
 * üìß V2 : Accorder l'acc√®s restaurant par email utilisateur
 */
export const grantRestaurantAccessByEmail = async (
  restaurantId: string, 
  userEmail: string,
  role: 'manager' | 'waiter' | 'chef' | 'cleaner',
  expiresAt?: number
): Promise<RestaurantAccessResult> => {
  try {
    console.log(`üìß V2: Attribution acc√®s ${role} par email ${userEmail} pour restaurant ${restaurantId}`);
    
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    const currentTime = Date.now();
    const expirationTime = expiresAt || (currentTime + (7 * 24 * 60 * 60 * 1000));

    // ‚úÖ Utiliser la Firebase Function V2 avec email
    const setRestaurantAccessV2Func = httpsCallable<RestaurantAccessDataV2, RestaurantAccessResult>(
      functions, 
      'setRestaurantAccessV2'
    );
    
    const result = await setRestaurantAccessV2Func({
      restaurantId,
      role,
      expiresAt: expirationTime,
      targetUserEmail: userEmail  // üìß Passer l'email directement
    });

    console.log('‚úÖ V2: Acc√®s accord√© par email et Custom Claims mis √† jour via Functions');
    return {
      success: true,
      message: `Acc√®s accord√© avec succ√®s √† ${userEmail}`,
      expiresAt: expirationTime,
      architecture: 'v2-functions-email',
      details: result.data
    };
    
  } catch (error: any) {
    console.error('‚ùå V2: Erreur attribution acc√®s par email:', error);
    throw new Error(`Erreur attribution acc√®s V2 par email: ${error.message}`);
  }
};

// =============== FONCTIONS LEGACY (COMPATIBILIT√â) ===============

/**
 * üéØ LEGACY : Accorder l'acc√®s restaurant (garde la compatibilit√© V1)
 */
export const grantRestaurantAccess = async (
  restaurantId: string, 
  role: 'manager' | 'waiter' | 'chef' | 'cleaner',
  expiresAt?: number
): Promise<RestaurantAccessResult> => {
  return grantRestaurantAccessV2(restaurantId, role, expiresAt);
};

/**
 * üö´ LEGACY : Supprimer l'acc√®s restaurant (garde la compatibilit√© V1)
 */
export const revokeRestaurantAccess = async (restaurantId: string): Promise<RestaurantAccessResult> => {
  return revokeRestaurantAccessV2(restaurantId);
};

/**
 * üìã LEGACY : Obtenir tous les acc√®s restaurant (garde la compatibilit√© V1)
 */
export const getMyRestaurantAccess = async (): Promise<RestaurantAccessResult> => {
  return getMyRestaurantAccessV2();
};

// =============== FONCTIONS CRITIQUES (FIREBASE FUNCTIONS) ===============

/**
 * üö® Verrouillage d'urgence d'un restaurant
 */
export const lockdownRestaurant = async (restaurantId: string): Promise<RestaurantAccessResult> => {
  try {
    console.log(`üö® Lockdown d'urgence restaurant ${restaurantId}`);
    
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    const emergencyLockdown = httpsCallable<{ restaurantId: string }, RestaurantAccessResult>(
      functions, 
      'emergencyLockdown'
    );
    
    const result = await emergencyLockdown({ restaurantId });

    console.log('üö® Lockdown effectu√©:', result.data);
    return result.data;
    
  } catch (error: any) {
    console.error('‚ùå Erreur lockdown:', error);
    throw new Error(`Erreur lockdown: ${error.message}`);
  }
};

/**
 * üîì Lever le verrouillage d'urgence d'un restaurant
 */
export const unlockRestaurant = async (restaurantId: string): Promise<RestaurantAccessResult> => {
  try {
    console.log(`üîì Lev√©e lockdown restaurant ${restaurantId}`);
    
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    const liftEmergencyLockdown = httpsCallable<{ restaurantId: string }, RestaurantAccessResult>(
      functions, 
      'liftEmergencyLockdown'
    );
    
    const result = await liftEmergencyLockdown({ restaurantId });

    console.log('üîì Lockdown lev√©:', result.data);
    return result.data;
    
  } catch (error: any) {
    console.error('‚ùå Erreur lev√©e lockdown:', error);
    throw new Error(`Erreur lev√©e lockdown: ${error.message}`);
  }
};

/**
 * üîç Debug des permissions utilisateur (d√©veloppement)
 */
export const debugUserPermissions = async (targetUserId?: string): Promise<RestaurantAccessResult> => {
  try {
    console.log('üîç Debug permissions utilisateur');
    
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    const debugUserClaims = httpsCallable<{ targetUserId?: string }, RestaurantAccessResult>(
      functions, 
      'debugUserClaims'
    );
    
    const result = await debugUserClaims({ targetUserId });

    console.log('üîç Debug info:', result.data);
    return result.data;
    
  } catch (error: any) {
    console.error('‚ùå Erreur debug:', error);
    throw new Error(`Erreur debug: ${error.message}`);
  }
};

// =============== FONCTIONS HELPER ===============

/**
 * ‚ö° RAPIDE : Lire les Custom Claims depuis le token (0-50ms)
 */
const getCustomClaimsFromToken = async (): Promise<any> => {
  try {
    if (!auth.currentUser) {
      return null;
    }

    const token = await auth.currentUser.getIdToken();
    const payload = JSON.parse(atob(token.split('.')[1]));
    
    return payload;
  } catch (error) {
    console.error('‚ùå Erreur lecture Custom Claims:', error);
    return null;
  }
};

/**
 * ‚ö° RAPIDE : V√©rifier si l'utilisateur a un r√¥le sp√©cifique
 */
export const hasRestaurantRole = async (
  restaurantId: string, 
  requiredRole: 'manager' | 'waiter' | 'chef' | 'cleaner'
): Promise<boolean> => {
  try {
    const claims = await getCustomClaimsFromToken();
    const restaurantAccess = claims?.restaurantAccess?.[restaurantId];
    
    if (!restaurantAccess) {
      return false;
    }

    const now = Date.now();
    if (restaurantAccess.expiresAt && restaurantAccess.expiresAt < now) {
      console.log('‚è∞ Acc√®s expir√© pour', restaurantId);
      return false;
    }

    const hasRole = restaurantAccess.role === requiredRole;
    console.log(`‚ö° Custom Claims check: ${restaurantId} ‚Üí ${requiredRole} = ${hasRole}`);
    return hasRole;
    
  } catch (error) {
    console.error('‚ùå Erreur v√©rification r√¥le (Custom Claims):', error);
    return false;
  }
};

/**
 * ‚ö° V2 : Obtenir la liste des restaurants accessibles depuis Custom Claims
 */
export const getAccessibleRestaurantsV2 = async (): Promise<string[]> => {
  try {
    const claims = await getCustomClaimsFromToken();
    const restaurantAccess = claims?.restaurantAccess || {};
    
    const now = Date.now();
    const restaurants = Object.keys(restaurantAccess).filter(restaurantId => {
      const access = restaurantAccess[restaurantId];
      return !access.expiresAt || access.expiresAt > now;
    });
    
    console.log(`‚ö° V2: Custom Claims: ${restaurants.length} restaurants accessibles:`, restaurants);
    return restaurants;
    
  } catch (error) {
    console.error('‚ùå V2: Erreur liste restaurants (Custom Claims):', error);
    return [];
  }
};

/**
 * ‚ö° LEGACY : Obtenir la liste des restaurants accessibles
 */
export const getAccessibleRestaurants = async (): Promise<string[]> => {
  return getAccessibleRestaurantsV2();
};

/**
 * ‚ö° RAPIDE : V√©rifier si l'utilisateur est manager d'un restaurant
 */
export const isRestaurantManager = async (restaurantId: string): Promise<boolean> => {
  return await hasRestaurantRole(restaurantId, 'manager');
};

/**
 * ‚ö° RAPIDE : Obtenir le r√¥le de l'utilisateur dans un restaurant
 */
export const getRestaurantRole = async (restaurantId: string): Promise<string | null> => {
  try {
    const claims = await getCustomClaimsFromToken();
    const restaurantAccess = claims?.restaurantAccess?.[restaurantId];
    
    if (!restaurantAccess) {
      return null;
    }

    const now = Date.now();
    if (restaurantAccess.expiresAt && restaurantAccess.expiresAt < now) {
      return null;
    }

    return restaurantAccess.role;
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration r√¥le:', error);
    return null;
  }
};

/**
 * ‚ö° RAPIDE : V√©rifier l'acc√®s simple √† un restaurant
 */
export const canAccessRestaurant = async (restaurantId: string): Promise<boolean> => {
  try {
    const claims = await getCustomClaimsFromToken();
    const restaurantAccess = claims?.restaurantAccess?.[restaurantId];
    
    if (!restaurantAccess) {
      return false;
    }

    const now = Date.now();
    if (restaurantAccess.expiresAt && restaurantAccess.expiresAt < now) {
      return false;
    }

    return true;
  } catch (error) {
    console.error('‚ùå Erreur v√©rification acc√®s:', error);
    return false;
  }
};

/**
 * üìä V2 : Obtenir tous les acc√®s avec m√©thode optimis√©e
 */
export const getMyRestaurantAccessOptimizedV2 = async (): Promise<{
  source: 'v2-functions' | 'customClaims';
  data: RestaurantAccessResult;
}> => {
  try {
    // 1. ‚ö° Essayer Custom Claims d'abord (rapide)
    const claims = await getCustomClaimsFromToken();
    if (claims?.restaurantAccess) {
      console.log('‚ö° V2: Utilisation Custom Claims (rapide)');
      return {
        source: 'customClaims',
        data: {
          success: true,
          message: 'Acc√®s r√©cup√©r√©s via Custom Claims',
          restaurantAccess: claims.restaurantAccess,
          totalRestaurants: Object.keys(claims.restaurantAccess).length,
          architecture: 'v2-customclaims'
        }
      };
    }

    // 2. üìã Utiliser les nouvelles Functions V2 (Collection Group Query)
    console.log('üìã V2: Utilisation Functions V2 (Collection Group)');
    const functionResult = await getMyRestaurantAccessV2();
    return {
      source: 'v2-functions',
      data: functionResult
    };

  } catch (error) {
    console.error('‚ùå V2: Erreur r√©cup√©ration acc√®s optimis√©e:', error);
    throw error;
  }
};


/**
 * üîÑ Forcer le refresh des Custom Claims c√¥t√© client
 */
export const refreshCustomClaims = async (): Promise<any> => {
  try {
    if (!auth.currentUser) {
      throw new Error('Utilisateur non connect√©');
    }

    console.log('üîÑ Refresh des Custom Claims...');
    
    // Forcer le refresh du token
    await auth.currentUser.getIdToken(true);
    
    // R√©cup√©rer les nouveaux claims
    const tokenResult = await auth.currentUser.getIdTokenResult();
    
    console.log('‚úÖ Custom Claims refresh√©s:', tokenResult.claims);
    return tokenResult.claims;
    
  } catch (error) {
    console.error('‚ùå Erreur refresh Custom Claims:', error);
    throw error;
  }
};

/**
 * üîç V√©rifier les Custom Claims actuels
 */
export const getCurrentCustomClaims = async (): Promise<any> => {
  try {
    if (!auth.currentUser) {
      return null;
    }

    const tokenResult = await auth.currentUser.getIdTokenResult();
    return tokenResult.claims;
    
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration Custom Claims:', error);
    return null;
  }
};

// =============== EXPORT DEFAULT ===============

export default {
  // üéØ V2 FUNCTIONS : Architecture robuste (recommand√©es)
  grantRestaurantAccessV2,
  revokeRestaurantAccessV2,
  getMyRestaurantAccessV2,
  getRestaurantUsersV2,
  getAccessibleRestaurantsV2,
  getMyRestaurantAccessOptimizedV2,

  // üîÑ LEGACY FUNCTIONS : Garde la compatibilit√© (d√©l√®guent vers V2)
  grantRestaurantAccess,
  revokeRestaurantAccess,
  getMyRestaurantAccess,
  getAccessibleRestaurants,
  
  // üî• ACTIONS CRITIQUES : Firebase Functions (s√©curis√©es)
  lockdownRestaurant,
  unlockRestaurant,
  debugUserPermissions,
  
  // ‚ö° V√âRIFICATIONS RAPIDES : Custom Claims (rapides)
  hasRestaurantRole,
  isRestaurantManager,
  getRestaurantRole,
  canAccessRestaurant,
};
